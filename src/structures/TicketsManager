import { ChannelType, Client, Collection } from 'discord.js';
import { createConnection } from 'mysql';
import { dbType } from '../typings/db';
import { ticket, ticketCreate } from '../typings/ticket';

const database_infos = {
    host: process.env.DATABASE_H,
    user: process.env.DATABASE_U,
    database: process.env.DATABASE_D,
    password: process.env.DATABASE_P
};
export const db: dbType = createConnection(database_infos);
db.connect((error?: string) => {
    if (error) throw error;
});

export class TicketsManager {
    readonly client: Client;
    private cache: Collection<string | number, ticket> = new Collection();

    constructor(client: Client) {
        this.client = client;
    }
    public start() {
        this.fillCache();
    }
    public async createTicket({ guild, user, subject }: ticketCreate): Promise<ticket> {
        return new Promise((resolve, reject) => {
            guild.channels.create({
                name: this.generateTicketName(guild.id),
                topic: `Ticket of ${user.id}.\nSubject: ${subject}`,
                type: ChannelType.GuildText,
                permissionOverwrites: [
                    {
                        id: guild.id,
                        deny: ['ViewChannel']
                    },
                    {
                        id: user.id,
                        allow: ['ViewChannel', 'SendMessages', 'AttachFiles', 'AddReactions', 'EmbedLinks']
                    }
                ]
            })
        });
    }
    private async fillCache() {
        const data = await this.query('SELECT * FROM tickets');
        this.cache.clear();

        for (const d of data) {
            this.cache.set(d.id.toString(), d);
        };
    }
    private async query(sql: string): Promise<ticket[]> {
        return new Promise((resolve, reject) => {
            db.query(sql, (error, request) => {
                if (error) return reject(error);
                resolve(request as ticket[]);
            });
        });
    }
    private getGreatestId(guild_id: string): number {
        const cached = this.cache.filter(x => x.guild_id === guild_id);
        if (cached.size === 0) return 0;

        let greatest = cached.first()?.id as number;
        cached.forEach((x) => {
            greatest = Math.max(greatest, x.id);
        });
        return greatest;
    }
    private generateTicketName(guild_id: string) {
        const max = this.getGreatestId(guild_id);
        const numberOfZeros = 4 - max.toString().length;

        if (numberOfZeros === 0) return 'ticket-' + max;
        return 'ticket-' + new Array(numberOfZeros).fill('0').join('') + max;
    }
}